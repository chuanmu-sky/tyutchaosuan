import torch
import numpy as np
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader
device = 'cuda:0'
'''----------------------------------------------------------------------------------------------'''
def GWO(fitness, lb, ub, dim, n, max_iter):
    # 初始化狼群的初始位置
    position = torch.rand(n, dim) * (ub - lb) + lb
    
    for i in range(max_iter):
        # 首先计算每个狼的适应性得分
        fitness_gwo = []
        for j in range(n):
            fitness_gwo.append(fitness(position[j]))
        
        # 得到每个狼排序后的得分以及对应的狼的编号
        fitness_gwo, num = torch.sort(torch.tensor(fitness_gwo))
        
        # 定义abd狼的位置
        alpha_position = position[num[0]]
        beta_position = position[num[1]]
        delta_position = position[num[2]]

        # 开始更新位置
        a = 2 * (1 - i / max_iter)

        for j in range(n):
            r1 = torch.rand(1)
            r2 = torch.rand(1)
            A1 = 2 * a * r1 - a
            D_alpha = torch.abs(2 * r2 - 1) * alpha_position - position[j]
            X1 = alpha_position - A1 * D_alpha 

            r1 = torch.rand(1)
            r2 = torch.rand(1)
            A2 = 2 * a * r1 - a
            D_beta = torch.abs(2 * r2 - 1) * beta_position - position[j]
            X2 = beta_position - A2 * D_beta 

            r1 = torch.rand(1)
            r2 = torch.rand(1)
            A3 = 2 * a * r1 - a
            D_delta = torch.abs(2 * r2 - 1) * delta_position - position[j]
            X3 = delta_position - A3 * D_delta

            position[j] = (X1 + X2 + X3) / 3

            # 位置限定
            for k in range(len(lb)):
                if position[j][k]<lb[k]:
                    position[j][k] = lb[k]
                if position[j][k]>ub[k]:
                    position[j][k] = ub[k]

        print(alpha_position)
    return alpha_position
'''----------------------------------------------------------------------------------------------'''
class LSTMModel(torch.nn.Module):
    def __init__(self, input_size, hidden_size, num_layers, output_size, dropout):
        super(LSTMModel, self).__init__()
        self.lstm = torch.nn.LSTM(input_size, hidden_size, num_layers, dropout=dropout)
        self.fc_0 = torch.nn.Linear(hidden_size, 64)
        self.fc_1 = torch.nn.Linear(64, output_size)

    def forward(self, x):
        # x的形状是(n, batch, input_size)
        # out的形状是(n, batch, input_size)
        out, _ = self.lstm(x)
        # 此时取最后一个时间序列 (batch, input_size)
        out = out[-1, :, :]
        # 最终输出 (batch, output_size)
        out = self.fc_1(self.fc_0(out))
        return out
'''----------------------------------------------------------------------------------------------'''
def fitness(a):
    hidden_size, deep, dropout, lr, mini_batch = int(a[0]), int(a[1]), a[2], a[3], int(a[4])
    
    input_size = 1
    output_size = 12

    node = 10

    input_size = 1
    output_size = 1
    
    model = list([LSTMModel(input_size, hidden_size, deep, output_size, 0.03).to(device) 
                 for i in range(node)])
    criterion = list([torch.nn.MSELoss()
                      for i in range(node)])
    optimizer = list(
                    [torch.optim.Adam(model[i].parameters(), lr)
                     for i in range(node)])

    train_data = np.load("D:\\develop\\data_train\\lstm\\Data\\train.npz")
    train_x = torch.tensor(train_data["x"]).transpose(1, 2)
    train_y = torch.tensor(train_data["y"]).transpose(1, 2)
    dataset = torch.cat((train_x, train_y),dim=2)
    train_data_set = DataLoader(dataset=dataset, batch_size=mini_batch, shuffle=True)

    for epoch in range(10):
        loss_all = [0,0,0,0,0,0,0,0,0,0]
        for _, data in enumerate(train_data_set, 0):
            x, y = data[:,:,0:48,:], data[:,:,48:60,:] 
            x = x.transpose(0, 1).contiguous().view(10, 48, -1, 1).to(device)
            y = y.transpose(0, 1).contiguous().view(10, -1, 12).to(device)

        for i in range(node):
            pred_y = model[i](x[i])
            optimizer[i].zero_grad()
            loss = criterion[i](pred_y, y[i])
            loss.backward()
            optimizer[i].step()
            loss_all[i] = loss

    for i in range(node):
        print('Node: {}, Train Loss: {:.5f}'.format(i+1, loss_all[i]))
    
    result = 0
    for i in range(10):
        result = result + loss_all[i]
    result = result/10
    print(result)
    return result.detach()
    
'''----------------------------------------------------------------------------------------------'''
GWO(fitness, torch.tensor([50, 2, 0, 0.03, 128],dtype=torch.float32), torch.tensor([200, 4, 0.3, 0.1, 3000],dtype=torch.float32), 5, 5, 10)
